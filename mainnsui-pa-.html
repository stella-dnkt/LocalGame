<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ã‚·ãƒ³ãƒ—ãƒ«ãƒ»ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</title>
<style>
  :root { --cell: 32px; }
  body {
    font-family: system-ui, -apple-system, "Segoe UI", sans-serif;
    display:flex; flex-direction:column; align-items:center;
    gap:12px; margin:20px;
  }
  .toolbar { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .toolbar span { font-weight: 600; }
  .board {
    display:grid;
    grid-template-columns: repeat(var(--cols), var(--cell));
    gap:2px;
    user-select:none;
    touch-action: manipulation;
    background:#aaa;             /* ç›¤å…¨ä½“ã®èƒŒæ™¯ */
    padding:4px;                 /* å‘¨å›²ã«ä½™ç™½ */
    border:2px solid #333;       /* é»’ã„å¤–æ  */
    border-radius:8px;
  }
  .cell {
    width: var(--cell); height: var(--cell);
    display:flex; align-items:center; justify-content:center;
    border:1px solid #888;       /* ã‚»ãƒ«å¢ƒç•Œç·š */
    background:#ccc;             /* ã‚»ãƒ«åˆæœŸèƒŒæ™¯ã‚°ãƒ¬ãƒ¼ */
    font-weight:700; cursor:pointer; border-radius:4px;
  }
  .cell.revealed { background:#eee; border-color:#cfcfcf; cursor:default; }
  .cell.mine.revealed { background:#f8c5c5; }
  .cell.flag::after { content:"ğŸš©"; }
  .cell.revealed.number0 { color: transparent; }
  .cell.revealed.number1 { color:#1976d2; }
  .cell.revealed.number2 { color:#2e7d32; }
  .cell.revealed.number3 { color:#d32f2f; }
  .cell.revealed.number4 { color:#512da8; }
  .cell.revealed.number5 { color:#6d4c41; }
  .cell.revealed.number6 { color:#00838f; }
  .cell.revealed.number7 { color:#000000; }
  .cell.revealed.number8 { color:#616161; }
  button, select {
    padding:6px 10px; border-radius:10px; border:1px solid #bdbdbd;
    background:#f7f7f7; font-weight:600;
  }
  .smiley { font-size:18px; }
  .muted { opacity:.55; }

  /* ãƒ’ãƒ³ãƒˆè¡¨ç¤ºç”¨ */
  .hint {
    outline:3px dashed #ff9800;
    outline-offset:-3px;
    animation: pulse 1s ease-in-out infinite;
  }
  @keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(255,152,0,.6); }
    70% { box-shadow: 0 0 0 8px rgba(255,152,0,0); }
    100% { box-shadow: 0 0 0 0 rgba(255,152,0,0); }
  }
</style>
</head>
<body>
  <div class="toolbar">
    <label>ãƒ¬ãƒ™ãƒ«:
      <select id="level">
        <option value="9,9,10">åˆç´š 9Ã—9ï¼ˆ10ï¼‰</option>
        <option value="16,16,40">ä¸­ç´š 16Ã—16ï¼ˆ40ï¼‰</option>
        <option value="30,16,99">ä¸Šç´š 30Ã—16ï¼ˆ99ï¼‰</option>
      </select>
    </label>
    <span>ğŸ’£ æ®‹ã‚Š: <span id="minesLeft">10</span></span>
    <button id="pause">â¸ ä¸€æ™‚åœæ­¢</button>
    <button id="assist">ğŸ†˜ ãŠåŠ©ã‘(<span id="assistLeft">5</span>)</button>
    <button id="reset" class="smiley">ğŸ” ãƒªã‚»ãƒƒãƒˆ</button>
    <span>â± <span id="time">0</span>s</span>
    <span id="status" class="muted">é€²è¡Œå‰</span>
  </div>

  <div id="board" class="board" style="--cols:9;"></div>

  <script>
  (() => {
    const boardEl = document.getElementById('board');
    const levelEl = document.getElementById('level');
    const minesLeftEl = document.getElementById('minesLeft');
    const timeEl = document.getElementById('time');
    const resetBtn = document.getElementById('reset');
    const pauseBtn = document.getElementById('pause');
    const assistBtn = document.getElementById('assist');
    const assistLeftEl = document.getElementById('assistLeft');
    const statusEl = document.getElementById('status');

    let cols = 9, rows = 9, mines = 10;
    let grid, revealedCount, flags, started, timerId, seconds, alive, paused;
    let assistLeft = 5;
    let lastHintCell = null;

    function setStatus(text) { statusEl.textContent = text; }

    function assistQuotaFor(c, r, m) {
      if (c===9 && r===9 && m===10) return 5;     // åˆç´š
      if (c===16 && r===16 && m===40) return 4;   // ä¸­ç´š
      if (c===30 && r===16 && m===99) return 3;   // ä¸Šç´š
      return 3; // ã‚«ã‚¹ã‚¿ãƒ æ™‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    }

    function init(c = cols, r = rows, m = mines) {
      cols = c; rows = r; mines = m;
      boardEl.style.setProperty('--cols', cols);
      boardEl.innerHTML = '';
      grid = Array.from({ length: rows }, () =>
        Array.from({ length: cols }, () => ({
          mine:false, number:0, revealed:false, flagged:false, el:null
        }))
      );
      revealedCount = 0; flags = 0; started = false; seconds = 0; alive = true; paused = false;
      clearInterval(timerId); timeEl.textContent = '0'; minesLeftEl.textContent = mines;
      pauseBtn.textContent = 'â¸ ä¸€æ™‚åœæ­¢'; pauseBtn.disabled = false;
      resetBtn.textContent = 'ğŸ” ãƒªã‚»ãƒƒãƒˆ';
      setStatus('é€²è¡Œå‰');

      // ãŠåŠ©ã‘å›æ•°ãƒªã‚»ãƒƒãƒˆ
      assistLeft = assistQuotaFor(cols, rows, mines);
      assistLeftEl.textContent = assistLeft;
      assistBtn.disabled = (assistLeft <= 0);

      lastHintCell = null;

      createCells();
    }

    function createCells() {
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const div = document.createElement('div');
          div.className = 'cell';
          div.dataset.x = x; div.dataset.y = y;
          div.addEventListener('contextmenu', e => e.preventDefault());
          div.addEventListener('mousedown', e => e.preventDefault());
          div.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            if (!alive || paused) return;
            if (e.button === 2) { toggleFlag(x, y); return; }
            reveal(x, y, true);
          });
          grid[y][x].el = div;
          boardEl.appendChild(div);
        }
      }
    }

    function neighborsCoords(x, y) {
      const coords = [];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx, ny = y + dy;
          if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
          coords.push([nx, ny]);
        }
      }
      return coords;
    }

    function placeMines(avoidX, avoidY) {
      let placed = 0;
      while (placed < mines) {
        const x = Math.floor(Math.random() * cols);
        const y = Math.floor(Math.random() * rows);
        const cell = grid[y][x];
        if (cell.mine) continue;
        if (Math.abs(x - avoidX) <= 1 && Math.abs(y - avoidY) <= 1) continue; // åˆæ‰‹å®‰å…¨
        cell.mine = true;
        placed++;
      }
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (grid[y][x].mine) continue;
          const n = neighborsCoords(x, y).filter(([nx, ny]) => grid[ny][nx].mine).length;
          grid[y][x].number = n;
        }
      }
    }

    function startTimer() {
      clearInterval(timerId);
      timerId = setInterval(() => { seconds++; timeEl.textContent = String(seconds); }, 1000);
    }
    function stopTimer() { clearInterval(timerId); }

    function togglePause(forceState = null) {
      if (!alive) return;
      if (!started) return;
      paused = forceState !== null ? forceState : !paused;
      if (paused) {
        stopTimer();
        setStatus('ä¸€æ™‚åœæ­¢ä¸­');
        pauseBtn.textContent = 'â–¶ å†é–‹';
      } else {
        startTimer();
        setStatus('é€²è¡Œä¸­');
        pauseBtn.textContent = 'â¸ ä¸€æ™‚åœæ­¢';
      }
    }

    document.addEventListener('visibilitychange', () => {
      if (document.hidden) togglePause(true);
    });
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { e.preventDefault(); togglePause(); }
    });

    function reveal(x, y, firstClick) {
      const cell = grid[y][x];
      if (cell.revealed || cell.flagged) return;

      // æ—¢å­˜ã®ãƒ’ãƒ³ãƒˆæ ã‚’æ¶ˆã™
      clearHint();

      if (!started) {
        placeMines(x, y);
        started = true;
        startTimer();
        setStatus('é€²è¡Œä¸­');
      }

      cell.revealed = true;
      cell.el.classList.add('revealed');

      if (cell.mine) {
        cell.el.classList.add('mine');
        cell.el.textContent = 'ğŸ’£';
        gameOver(false);
        return;
      }

      revealedCount++;
      if (cell.number > 0) {
        cell.el.textContent = cell.number;
        cell.el.classList.add('number' + cell.number);
      } else {
        cell.el.classList.add('number0');
        flood(x, y);
      }
      checkWin();
    }

    function flood(x, y) {
      neighborsCoords(x, y).forEach(([nx, ny]) => {
        const n = grid[ny][nx];
        if (!n.revealed && !n.mine && !n.flagged) {
          reveal(nx, ny, false);
        }
      });
    }

    function toggleFlag(x, y) {
      const cell = grid[y][x];
      if (cell.revealed) return;
      cell.flagged = !cell.flagged;
      cell.el.classList.toggle('flag', cell.flagged);
      cell.el.textContent = cell.flagged ? 'ğŸš©' : '';
      flags += cell.flagged ? 1 : -1;
      minesLeftEl.textContent = mines - flags;
    }

    function revealAllMines() {
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const c = grid[ny=y]?.[nx=x] ?? grid[y][x]; // safety
          const cell = grid[y][x];
          if (cell.mine) {
            cell.el.classList.add('revealed','mine');
            if (!cell.flagged) cell.el.textContent = 'ğŸ’£';
          }
        }
      }
    }

    function gameOver(win) {
      alive = false;
      stopTimer();
      if (!win) {
        revealAllMines();
        setStatus('çˆ†ç™ºï¼ãƒªã‚»ãƒƒãƒˆã—ã¦å†é–‹ã—ã¦ã­');
      } else {
        setStatus('ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†');
      }
      pauseBtn.disabled = true;
      pauseBtn.textContent = 'â¸ ä¸€æ™‚åœæ­¢';
      assistBtn.disabled = true;
      clearHint();
    }

    function checkWin() {
      const safe = cols * rows - mines;
      if (revealedCount >= safe) gameOver(true);
    }

    /* ===== ãŠåŠ©ã‘ãƒ­ã‚¸ãƒƒã‚¯ =====
       1) ç›¤é–‹å§‹å‰: ç›¤ä¸­å¤®ãªã©ä»»æ„ã®ãƒã‚¹ã‚’æç¤ºï¼ˆåˆæ‰‹å®‰å…¨ä»•æ§˜ã«ã‚ˆã‚Šå®‰å…¨ï¼‰
       2) ç›¤é€²è¡Œä¸­: ã€Œæ——ã®æ•°ï¼æ•°å­—ã€ãªé–‹ç¤ºã‚»ãƒ«ã®æœªé–‹ç¤ºéš£æ¥ã¯å®‰å…¨ â†’ ãã‚Œã‚’æç¤º
       3) ä¸Šè¨˜ã§è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ã€å†…éƒ¨æƒ…å ±ã§çˆ†å¼¾ã§ãªã„æœªé–‹ç¤ºãƒã‚¹ã‚’æç¤ºï¼ˆãƒãƒ¼ãƒˆçš„ä¿è¨¼ï¼‰
    */
    function clearHint() {
      if (lastHintCell) {
        lastHintCell.classList.remove('hint');
        lastHintCell = null;
      }
    }

    function findDeductivelySafe() {
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const c = grid[y][x];
          if (!c.revealed || c.number === 0) continue;
          const neigh = neighborsCoords(x, y);
          const hidden = neigh.filter(([nx, ny]) => !grid[ny][nx].revealed && !grid[ny][nx].flagged);
          if (hidden.length === 0) continue;
          const flagsAround = neigh.filter(([nx, ny]) => grid[ny][nx].flagged).length;
          if (flagsAround === c.number) {
            // å…¨hiddenã¯å®‰å…¨
            const [sx, sy] = hidden[0];
            return grid[sy][sx];
          }
        }
      }
      return null;
    }

    function findAnySafeCell() {
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const c = grid[y][x];
          if (!c.revealed && !c.flagged && !c.mine) return c;
        }
      }
      return null;
    }

    function suggestSafeCell() {
      if (!alive) return;
      if (assistLeft <= 0) return;

      clearHint();

      let target = null;

      if (!started) {
        // é–‹å§‹å‰ã¯ä¸­å¤®æ¨å¥¨ï¼ˆä»»æ„ã§OKã€‚åˆæ‰‹å®‰å…¨è¦å‰‡ã«ã‚ˆã‚Šå®‰å…¨ï¼‰
        const cx = Math.floor(cols / 2), cy = Math.floor(rows / 2);
        target = grid[cy][cx];
      } else {
        target = findDeductivelySafe() || findAnySafeCell();
      }

      if (!target) {
        setStatus('ãƒ’ãƒ³ãƒˆãªã—ï¼ˆå®‰å…¨ãƒã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼‰');
        return;
      }

      target.el.classList.add('hint');
      lastHintCell = target.el;

      assistLeft--;
      assistLeftEl.textContent = assistLeft;
      if (assistLeft <= 0) assistBtn.disabled = true;

      setStatus('ğŸ†˜ ã“ã®ãƒã‚¹ã¯å®‰å…¨ã ã‚ˆï¼ˆãƒã‚¤ãƒ©ã‚¤ãƒˆä¸­ï¼‰');
      // 3ç§’å¾Œã«è‡ªå‹•ã§ãƒã‚¤ãƒ©ã‚¤ãƒˆè§£é™¤ï¼ˆä»»æ„ï¼‰
      setTimeout(() => { if (lastHintCell === target.el) clearHint(); }, 3000);
    }

    levelEl.addEventListener('change', () => {
      const [c, r, m] = levelEl.value.split(',').map(Number);
      init(c, r, m);
    });

    resetBtn.addEventListener('click', () => init());
    pauseBtn.addEventListener('click', () => togglePause());
    assistBtn.addEventListener('click', () => suggestSafeCell());

    init();
  })();
  </script>
</body>
</html>
