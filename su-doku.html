<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æ•°ç‹¬ï¼ˆãƒŠãƒ³ãƒ—ãƒ¬ï¼‰HTMLç‰ˆ</title>
  <style>
    :root {
      --gunjo: #1e3a8a;           /* ç¾¤é’ï¼ˆå¤–æ /3x3å¤ªç·šï¼‰ */
      --gunjo-thin: #4338ca;      /* ç ´ç·šã®è‰² */
      --fg: #111827;
      --muted: #6b7280;
      --card: #ffffff;
      --danger: #dc2626;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif; background: linear-gradient(#fff,#eef2ff); color: var(--fg); }

    .container { width: min(100%, 1100px); margin: 0 auto; padding: 16px; }

    /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
    .topbar { display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 8px; margin: 4px 0 16px; }
    .left { justify-self: start; display: inline-flex; align-items: center; gap: 8px; }
    .center { justify-self: center; font-weight: 700; }
    .right { justify-self: end; }
    select, button { font-size: 14px; }
    select { padding: 6px 10px; border-radius: 12px; border: 1px solid #c7d2fe; background: #fff; }
    .btn { padding: 8px 14px; border-radius: 14px; border: 1px solid #c7d2fe; background:#fff; cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,.05); }
    .btn:hover { box-shadow: 0 2px 6px rgba(0,0,0,.08); }

    /* ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
    .layout { display: grid; grid-template-columns: 1fr; gap: 20px; }
    @media (min-width: 980px) { .layout { grid-template-columns: 1fr 320px; align-items: start; }}

    /* ç›¤é¢ */
    .board-wrap { position: relative; width: min(90vw,520px); aspect-ratio: 1/1; margin: 0 auto; border: 4px solid var(--gunjo); border-radius: 14px; background:#fff; overflow:hidden; }
    .cells { display:grid; grid-template-columns: repeat(9,1fr); grid-template-rows: repeat(9,1fr); height:100%; }
    .cell { display:flex; align-items:center; justify-content:center; font-weight:700; font-size:clamp(16px,2.6vw,24px); color:var(--gunjo); background:transparent; cursor:pointer; }

    /* 3x3 ã®å¤ªç·šï¼ˆå¤–æ ã‚‚å¤ªç·šãªã®ã§ã‚»ãƒ«å´ã¯å·¦ãƒ»ä¸Šã ã‘ã«ä»˜ä¸ã—ã¦äºŒé‡åŒ–é˜²æ­¢ï¼‰ */
    .bl3 { border-left: 2px solid var(--gunjo); }
    .bt3 { border-top: 2px solid var(--gunjo); }

    /* 3x3 å†…éƒ¨ã¯ç ´ç·šï¼ˆå·¦ãƒ»ä¸Šã®ã¿ï¼‰ */
    .bl-dash { border-left: 1px dashed var(--gunjo-thin); }
    .bt-dash { border-top: 1px dashed var(--gunjo-thin); }

    .cell.given { color:#0f172a; }
    .cell.selected { outline:2px solid #a5b4fc; background:#eef2ff; }
    .cell.samegroup { background:#f3f4ff; }
    .cell.samenum { background:#eaeaff; }
    .cell.conflict { color:var(--danger); }

    .notes { display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr); width:90%; height:90%; }
    .note { font-size:clamp(9px,1.5vw,11px); color:var(--gunjo-thin); display:flex; align-items:center; justify-content:center; }

    /* ãƒ‘ãƒãƒ« */
    .panel { background: var(--card); border:1px solid #e0e7ff; border-radius: 18px; padding: 14px; box-shadow: 0 1px 10px rgba(0,0,0,.04); }
    .panel-header { display:flex; align-items:center; justify-content:space-between; margin-bottom:8px; }
    .keypad { display:grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .keypad button { height: 48px; border-radius: 14px; border:1px solid #c7d2fe; background:#fff; font-weight:700; color:var(--gunjo); cursor:pointer; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }

    .hint { font-size: 12px; color: var(--muted); margin-top: 10px; line-height: 1.6; }
    .clear-msg { text-align:center; color:#059669; font-weight:700; margin-top:10px; }
  </style>
</head>
<body>
  <div class="container">
    <div class="topbar">
      <div class="left">
        <label for="mode">ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ</label>
        <select id="mode">
          <option>åˆç´š</option>
          <option>ä¸­ç´š</option>
          <option>ä¸Šç´š</option>
        </select>
      </div>
      <div class="center">çµŒéæ™‚é–“ï¼š<span id="elapsed">00:00</span></div>
      <div class="right" style="display:flex; gap:8px; flex-wrap:wrap">
        <button id="reset" class="btn">åˆæœŸåŒ–</button>
        <button id="newGame" class="btn">æ–°è¦ã‚²ãƒ¼ãƒ </button>
      </div>
    </div>

    <div class="layout">
      <!-- ç›¤é¢ -->
      <div>
        <div class="board-wrap">
          <div id="cells" class="cells"></div>
        </div>
        <div id="clear" class="clear-msg" style="display:none">ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ ğŸ‰</div>
      </div>

      <!-- æ“ä½œãƒ‘ãƒãƒ« -->
      <aside class="panel">
        <div class="panel-header">
          <div style="font-weight:600">æ•°å­—é¸æŠ</div>
          <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center">
            <button id="noteToggle" class="btn">ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ï¼šOFF</button>
            <button id="hlLineToggle" class="btn">è¡Œåˆ—/ãƒ–ãƒ­ãƒƒã‚¯ï¼šON</button>
            <button id="hlSameToggle" class="btn">åŒå€¤ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼šON</button>
          </div>
        </div>
        <div id="keypad" class="keypad"></div>
        <div class="row">
          <button id="erase" class="btn">æ¶ˆå»</button>
          <button id="pause" class="btn">ä¸€æ™‚åœæ­¢</button>
        </div>
        <div class="hint">
          ãƒ»å¤–æ ã¨ 3Ã—3 å¢ƒç•Œã¯<strong style="color:var(--gunjo)">å¤ªç·š</strong><br>
          ãƒ»3Ã—3 å†…éƒ¨ã¯<strong style="color:var(--gunjo-thin)">ç ´ç·š</strong><br>
          ãƒ»é¸æŠè¡Œ/åˆ—/ãƒ–ãƒ­ãƒƒã‚¯ã€åŒå€¤ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã¯å€‹åˆ¥ã«ON/OFFã§ãã¾ã™ï¼ˆL / S ã‚­ãƒ¼ï¼‰
        </div>
      </aside>
    </div>
  </div>

<script>
(() => {
  const MODE_TO_CLUES = { "åˆç´š": 42, "ä¸­ç´š": 34, "ä¸Šç´š": 26 };

  // â€”â€” ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ â€”â€”
  const deepCopy = (b) => b.map(r => r.slice());
  const shuffle = (arr) => { const a = arr.slice(); for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; };
  const nextEmpty = (b) => { for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (b[r][c]===0) return [r,c]; return null; };
  const isValid = (b, r, c, v) => {
    for (let x=0;x<9;x++) if (b[r][x]===v) return false;
    for (let y=0;y<9;y++) if (b[y][c]===v) return false;
    const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
    for (let y=0;y<3;y++) for (let x=0;x<3;x++) { if (b[br+y][bc+x]===v) return false; }
    return true;
  };
  const solveBoard = (b) => { const e=nextEmpty(b); if(!e) return true; const [r,c]=e; for (const n of shuffle([1,2,3,4,5,6,7,8,9])) { if (isValid(b,r,c,n)) { b[r][c]=n; if (solveBoard(b)) return true; b[r][c]=0; } } return false; };
  const countSolutions = (b, limit=2) => { const e=nextEmpty(b); if(!e) return 1; let total=0; const [r,c]=e; for (let n=1;n<=9;n++){ if(isValid(b,r,c,n)){ b[r][c]=n; total+=countSolutions(b,limit); b[r][c]=0; if(total>=limit) return total; }} return total; };
  const generateCompleteBoard = () => { const b=Array.from({length:9},()=>Array(9).fill(0)); solveBoard(b); return b; };
  const generatePuzzle = (mode) => {
    const solution = generateCompleteBoard();
    const puzzle = deepCopy(solution);
    const target = MODE_TO_CLUES[mode] ?? 42;
    let clues = 81;
    const cells = shuffle([...Array(81).keys()]);
    while (cells.length && clues > target) {
      const pos = cells.pop();
      const r = Math.floor(pos/9), c = pos%9;
      if (puzzle[r][c]===0) continue;
      const back = puzzle[r][c];
      puzzle[r][c]=0;
      const tmp = deepCopy(puzzle);
      const solutions = countSolutions(tmp, 2);
      if (solutions !== 1) { puzzle[r][c]=back; }
      else { clues--; }
    }
    return { puzzle, solution };
  };
  const fmt = (sec)=>{ const h=String(Math.floor(sec/3600)).padStart(2,'0'); const m=String(Math.floor((sec%3600)/60)).padStart(2,'0'); const s=String(sec%60).padStart(2,'0'); return h!=='00'?`${h}:${m}:${s}`:`${m}:${s}`; };

  // â€”â€” çŠ¶æ…‹ â€”â€”
  let mode = 'åˆç´š';
  let puzzle, solution, grid, givenMask;
  let notes = new Map(); // key = idx -> Set<number>
  let selected = null;
  let noteMode = false;
  let highlightLine = true;   // è¡Œ/åˆ—/ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  let highlightSame = true;   // åŒã˜æ•°å­—ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
  let elapsed = 0, running = true, timerId = null;
  let cleared = false;

  // â€”â€” è¦ç´ å‚ç…§ â€”â€”
  const elMode = document.getElementById('mode');
  const elCells = document.getElementById('cells');
  const elElapsed = document.getElementById('elapsed');
  const elReset = document.getElementById('reset');
  const elKeypad = document.getElementById('keypad');
  const elNote = document.getElementById('noteToggle');
  const elHlLine = document.getElementById('hlLineToggle');
  const elHlSame = document.getElementById('hlSameToggle');
  const elNewGame = document.getElementById('newGame');
  const elErase = document.getElementById('erase');
  const elPause = document.getElementById('pause');
  const elClear = document.getElementById('clear');

  // â€”â€” åˆæœŸåŒ– â€”â€”
  function newGame(newMode = mode) {
    mode = newMode;
    const data = generatePuzzle(mode);
    puzzle = data.puzzle; solution = data.solution; grid = deepCopy(puzzle);
    givenMask = grid.flat().map(v=>v!==0);
    notes = new Map(); selected = null; elapsed = 0; running = true; cleared = false;
    elClear.style.display = 'none';
    // ã‚¿ã‚¤ãƒãƒ¼ã¯æœ€åˆã®ä¸€æ‰‹ã¾ã§é–‹å§‹ã—ãªã„
    if (timerId) { clearInterval(timerId); timerId = null; }
    elElapsed.textContent = fmt(elapsed);
    renderAll();
  }

  function resetGame() { // ç¾åœ¨ã®ç›¤é¢ã‚’åˆæœŸçŠ¶æ…‹ã¸
    grid = deepCopy(puzzle);
    notes = new Map(); selected = null; elapsed = 0; running = true; cleared = false;
    elClear.style.display = 'none';
    // ã‚¿ã‚¤ãƒãƒ¼ã¯ä¸€æ‰‹ç›®ã¾ã§å‹•ã‹ã•ãªã„
    if (timerId) { clearInterval(timerId); timerId = null; }
    elElapsed.textContent = fmt(elapsed);
    renderAll();
  }

  function startTimer(){ if (timerId) clearInterval(timerId); timerId = setInterval(()=>{ if(running){ elapsed++; elElapsed.textContent = fmt(elapsed);} }, 1000); elElapsed.textContent = fmt(elapsed); }

  function maybeStartTimer(){ if (timerId == null) startTimer(); }

  // â€”â€” ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° â€”â€”
  function renderAll(){
    // ã‚»ãƒ«ç”Ÿæˆ
    if (elCells.childElementCount !== 81) {
      elCells.innerHTML = '';
      for (let i=0;i<81;i++) {
        const btn = document.createElement('button');
        btn.className = 'cell';
        btn.dataset.idx = i;
        btn.addEventListener('click', () => onCellClick(i));
        elCells.appendChild(btn);
      }
    }
    // ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰
    if (elKeypad.childElementCount !== 9) {
      elKeypad.innerHTML = '';
      for (let i=1;i<=9;i++) {
        const b = document.createElement('button');
        b.textContent = String(i);
        b.addEventListener('click',()=> setValue(i));
        elKeypad.appendChild(b);
      }
    }
    updateCells();
  }

  function updateCells(){
    for (let idx=0; idx<81; idx++) {
      const el = elCells.children[idx];
      const r = Math.floor(idx/9), c = idx%9;
      const val = grid[r][c];

      // ãƒ™ãƒ¼ã‚¹ã‚¯ãƒ©ã‚¹
      el.className = 'cell';

      // ç·šã®ä»˜ä¸ï¼ˆå·¦ãƒ»ä¸Šã®ã¿ï¼‰
      if (c>0) {
        if (c%3===0) el.classList.add('bl3');
        else el.classList.add('bl-dash');
      }
      if (r>0) {
        if (r%3===0) el.classList.add('bt3');
        else el.classList.add('bt-dash');
      }

      if (givenMask[idx]) el.classList.add('given');
      if (selected === idx) el.classList.add('selected');
      if (selected != null){
        const sr = Math.floor(selected/9), sc = selected%9;
        if (highlightLine) {
          const sameGroup = (r===sr || c===sc || (Math.floor(r/3)===Math.floor(sr/3) && Math.floor(c/3)===Math.floor(sc/3)));
          if (sameGroup) el.classList.add('samegroup');
        }
        if (highlightSame) {
          const selVal = grid[sr][sc];
          if (selVal!==0 && selVal===val) el.classList.add('samenum');
        }
      }
      const conflict = isConflictDisplay(r,c,val);
      if (conflict) el.classList.add('conflict');

      // å†…å®¹
      if (val !== 0) {
        el.innerHTML = String(val);
      } else {
        const nset = notes.get(idx) || new Set();
        let html = '<div class="notes">';
        for (let k=1;k<=9;k++) html += `<div class="note">${nset.has(k)?k:''}</div>`;
        html += '</div>';
        el.innerHTML = html;
      }
    }
  }

  function isConflictDisplay(r,c,val){
    if (val===0) return false;
    // è¡Œ
    for (let x=0;x<9;x++) if (x!==c && grid[r][x]===val) return true;
    // åˆ—
    for (let y=0;y<9;y++) if (y!==r && grid[y][c]===val) return true;
    // ãƒ–ãƒ­ãƒƒã‚¯
    const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
    for (let y=0;y<3;y++) for (let x=0;x<3;x++) {
      const rr=br+y, cc=bc+x; if (!(rr===r && cc===c) && grid[rr][cc]===val) return true;
    }
    return false;
  }

  // â€”â€” æ“ä½œ â€”â€”
  function onCellClick(idx){ selected = idx; updateCells(); }

  function setValue(n){
    if (selected==null) return;
    const r=Math.floor(selected/9), c=selected%9;
    if (puzzle[r][c]!==0) return; // ä¸ãˆã‚‰ã‚ŒãŸãƒã‚¹ã¯ä¸å¯
    // ä¸€æ‰‹ç›®ã§ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹
    maybeStartTimer();
    if (noteMode) {
      const key = selected;
      const set = new Set(notes.get(key) || []);
      if (set.has(n)) set.delete(n); else set.add(n);
      notes.set(key,set);
    } else {
      grid[r][c]=n; // å€¤ã‚’å…¥ã‚Œã‚‹
      notes.delete(selected);
    }
    updateCells();
    checkClear();
  }

  function erase(){
    if (selected==null) return;
    const r=Math.floor(selected/9), c=selected%9;
    if (puzzle[r][c]!==0) return;
    // ä¸€æ‰‹ç›®ã§ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹ï¼ˆæ¶ˆå»ã‚‚æ‰‹ã¨ã—ã¦æ‰±ã†ï¼‰
    maybeStartTimer();
    grid[r][c]=0; notes.delete(selected);
    updateCells();
  }

  function toggleNote(){
    noteMode = !noteMode;
    elNote.textContent = `ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ï¼š${noteMode? 'ON':'OFF'}`;
  }

  function toggleHighlightLine(){
    highlightLine = !highlightLine;
    elHlLine.textContent = `è¡Œåˆ—/ãƒ–ãƒ­ãƒƒã‚¯ï¼š${highlightLine? 'ON':'OFF'}`;
    updateCells();
  }

  function toggleHighlightSame(){
    highlightSame = !highlightSame;
    elHlSame.textContent = `åŒå€¤ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼š${highlightSame? 'ON':'OFF'}`;
    updateCells();
  }

  function togglePause(){ running = !running; elPause.textContent = running? 'ä¸€æ™‚åœæ­¢':'å†é–‹'; }

  function checkClear(){
    for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (grid[r][c]===0) return; // æœªå®Œ
    // å³å¯†ä¸€è‡´
    for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (grid[r][c]!==solution[r][c]) return;
    running=false; cleared=true; elClear.style.display='block';
  }

  // â€”â€” ã‚¤ãƒ™ãƒ³ãƒˆ â€”â€”
  elMode.addEventListener('change', e => newGame(e.target.value));
  elReset.addEventListener('click', resetGame);
  elNewGame.addEventListener('click', () => newGame(mode));
  elNote.addEventListener('click', toggleNote);
  elHlLine.addEventListener('click', toggleHighlightLine);
  elHlSame.addEventListener('click', toggleHighlightSame);
  elErase.addEventListener('click', erase);
  elPause.addEventListener('click', togglePause);
  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ï¼ˆé¸æŠä¸­ã‚»ãƒ«ã« 1..9/0/Backspaceï¼‰
  window.addEventListener('keydown', (ev)=>{
    if (selected==null) return;
    const k = ev.key;
    if (/^[1-9]$/.test(k)) setValue(Number(k));
    else if (k==='0' || k==='Backspace' || k==='Delete') erase();
    else if (k==='n' || k==='N') toggleNote();
    else if (k==='l' || k==='L') toggleHighlightLine();
    else if (k==='s' || k==='S') toggleHighlightSame();
  });

  // èµ·å‹•
  newGame('åˆç´š');
})();
</script>
</body>
</html>
